<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yannick Mahe's blog</title>
    <description></description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>The first time a program I wrote got redistributed (without my knowledge)</title>
        <description>&lt;p&gt;This is a story from way back when I first started to program, in 1997 to be exact. It was the year I entered high school. Every students was required to have a &lt;a href='http://en.wikipedia.org/wiki/TI-80'&gt;TI-80&lt;/a&gt; or higher, an entry level programmable graphical calculator.&lt;/p&gt;

&lt;p&gt;&lt;img src='/assets/TI80.jpg' alt='TI-80' /&gt; I started programming as soon as one of my friends showed me how he had created a rock-paper-scissors program on his TI-80, and could never program enough. I programmed before, during and after class - much to the irritation of my teachers (using a calculator in French class is somewhat conspicuous). Like many people who ended up being programmers, I had just found something I loved. My TI-80 is dead now, I tore it apart to try and put it back together as soon as I upgraded, the next year.&lt;/p&gt;

&lt;p&gt;Programming on the TI-80 was, in retrospect, a peculiar experience. The language was TI-BASIC, which was a quirky language to say the least especially, in its TI-80 form:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the keyboard was calculator style, with the letters ordered alphabetically&lt;/li&gt;

&lt;li&gt;you didn&amp;#8217;t type the program text but inputted &lt;a href='http://en.wikipedia.org/wiki/Lexical_analysis'&gt;lexemes&lt;/a&gt; directly. For example, to use a for loop, you didn&amp;#8217;t type the letter F, O and R, but you went in the &amp;#8220;Program&amp;#8221; menu, and chose the seventh item from the list. In your program code, the &amp;#8220;FOR(&amp;#8221; would be then be displayed and you could input your parameters.&lt;/li&gt;

&lt;li&gt;there was no way to comment your code&lt;/li&gt;

&lt;li&gt;variable names were all exactly one letter long and always in caps (in fact everything was always in caps); and variables could only hold a float value. Some of these variables could be overwritten by the system. X and Y notably got set to coordinates chosen on the screen, so you could never use these variables in any program with graphical capabilities. This meant that you could use at most 25 variables (the greek letter theta was also available) in a program, all with nondescript names. All these variables were system-wide global variables.&lt;/li&gt;

&lt;li&gt;you couldn&amp;#8217;t create macros or functions in a program. You could call a program from another program, but there was no direct way to pass results from one program to the other.&lt;/li&gt;

&lt;li&gt;the only data model available were arrays, called lists. There were only 6 lists available, with a max size of 99 items, and of course they could only store floats.&lt;/li&gt;

&lt;li&gt;there was no way to get data from the user during the program run apart from a prompt. This meant there was no way for the calculator to tell which key was being pressed, so any real time interaction was out of the question&lt;/li&gt;

&lt;li&gt;storing data in variables was done in the opposite way to the standard. Instead of typing: A = 1, you typed: 1-&amp;gt;A&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Of course, there were also strong limitations with the hardware. there was only 7Kb of RAM on the calculator and no ROM, so you checked every byte to make sure your program would fit, and could run without hitting &amp;#8220;ERR: MEMORY&amp;#8221; the screen was 2-colors, of course, and a very small screen (76 by 80 if I remember correctly) there was no data input port. This meant you were limited to TI-BASIC and couldn&amp;#8217;t use any Assembly, like other TIs could. This also meant that if you wanted to use a program a friend had had or that you found on the Internet, the only way to get it was to retype it entirely.&lt;/p&gt;

&lt;p&gt;At the time though, I didn&amp;#8217;t realise that was weird in any way. It was just how you programmed.&lt;/p&gt;

&lt;p&gt;&lt;a href='http://en.wikipedia.org/wiki/Edsger_W._Dijkstra'&gt;Edsger W. Dijkstra&lt;/a&gt; famously said that those that start to learn programming with Basic become brain damaged. I&amp;#8217;m glad to report, there seems to be few lasting repercussions on my programming style. At least, I don&amp;#8217;t think it is.&lt;/p&gt;

&lt;p&gt;What I mainly programmed was games. I started with some glorified rock-paper-scissors, and went on to more advanced territory. The one I liked the most was Minesweeper. Programming has always seemed more fun to me than actually playing the games I developed, but Minesweeper was one the few games I wrote that I actually used more than a few times.&lt;/p&gt;

&lt;p&gt;After that, I tried to do even more advanced games, but the wall that I hit was the calculator&amp;#8217;s inability to allow real time interaction. This limited me to turn based games, which often (in my opinion) are no fun. Especially with a low-level game designer like I am. I tried strategy games, but couldn&amp;#8217;t come up with a sufficiently advanced AI to make the game any fun to play.&lt;/p&gt;

&lt;p&gt;That&amp;#8217;s when I tried something else: I actually developed my own version of Sim-City for the TI-80. It was very limited, both graphically and in functionality, but it was pretty fun to play. I was somewhat proud of myself for that one.&lt;/p&gt;

&lt;p&gt;A friend of mine had started his own website, on a Geocities type service provided by his ISP. He asked me if he could put my programs on his website. I, of course, was okay with it. So he typed the whole source code manually on his computer and put it on his website. In essence, before I had any real idea was Open Source was, I had released my first open source software.&lt;/p&gt;

&lt;p&gt;A few years later, I randomly googled &amp;#8220;TI-80 games&amp;#8221; and found on a website I had never heard of, a list of a few games. (the website is still online today: &lt;a href='http://www.ti80.online.fr/jeux.php3'&gt;http://www.ti80.online.fr/jeux.php3&lt;/a&gt; - in french) The last one of the list was Sim-City. The one I had programmed. Apparently, someone had stumbled onto my friend&amp;#8217;s page, and copied the game on their calculator, played it, and found it good enough to put on their website. The only part that was slightly annoying was that they had removed my name from the program (pretty easy to do: remove DISP &amp;#8220;BY YANNICK&amp;#8221; from the code).&lt;/p&gt;

&lt;p&gt;I guess I got &amp;#8220;pirated&amp;#8221; but it was a pretty awesome feeling: somebody, somewhere, was actually playing a game I had created! But the best part was when I found somebody had used the game and liked it so much&amp;#8230; they wrote a strategy guide.&lt;/p&gt;</description>
        <pubDate>Tue, 20 Aug 2013 17:28:42 +0200</pubDate>
        <link>/coding/2013/08/20/the-first-time-my-code-got-redistributed.html</link>
        <guid isPermaLink="true">/coding/2013/08/20/the-first-time-my-code-got-redistributed.html</guid>
      </item>
    
      <item>
        <title>The Walking Dead: the consequences of living with a legacy PHP framework</title>
        <description>&lt;p&gt;At our company, our main web app is based on Symfony 1.0, a PHP framework released in 2008. It was developped by a company called Sensio and open-sourced shortly after. It was a great framework when it came out, with all the good ideas from Ruby On Rails, CakePHP, etc. as well as great documentation, tutorials and a growing community. It is completely MVC, lets you write clean code, and does a lot of things a modern framework is supposed to let you do. But version 1.0 is clearly obsolete, and it is still our main framework.&lt;/p&gt;

&lt;p&gt;Since that framework came out, its subsequent versions, Symfony 1.1, 1.2, 1.3, 1.4 came out and died out. The 1.4 version came with a 3 year long term support promise from Sensio which ended in 2012. All the 1.X versions are based on the same overall architecture, and same principles. Sensio also released Symfony 2.0, 2.1, 2.2 and very recently, 2.3. which have a whole new architecture. This means a migration to those versions would all but require a complete rewrite&lt;/p&gt;

&lt;p&gt;We still develop on Symfony 1.0. There are a number of reasons why no migration was done:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;early migrations were deemed somewhat unnecessary&lt;/li&gt;

&lt;li&gt;migrations are inherently risky&lt;/li&gt;

&lt;li&gt;the product became our main product only later on, it wasn&amp;#8217;t the company&amp;#8217;s focus in the beginning&lt;/li&gt;

&lt;li&gt;the company lacked a CTO able to articulate the use of spending money to upgrade a product that worked (i.e. politics)&lt;/li&gt;

&lt;li&gt;new &amp;#8220;visible&amp;#8221; features were deemed more important than technical upgrades.&lt;/li&gt;

&lt;li&gt;debugging was a full-time job at some point, leaving no time for an upgrade&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Three years into the product&amp;#8217;s life an effort was done to do a complete rewrite of the product using Symfony 2.X. It was to be done by a consulting company, and preliminary research was already finished when I joined the company. This project was stopped for several reasons, including cost (well into the six figures, a lot for a small company) and an estimated 6-month &amp;#8220;no new feature&amp;#8221; period (which in my opinion would have evolved into a 9-month to one year period). The biggest issue was that our existing client base would not have benefited from the migration. As we are a SaaS company with a recurring business model, keeping existing clients is as important to us as acquiring new clients. Other issues that didn&amp;#8217;t play a role in the decision to stop the rewrite but would have been problems if we had kept going were : new software isn&amp;#8217;t as reliable as production software. New software requires new training. It was not possible to be feature equivalent in that short period, so our new application would have been behind what our competition is able to do.&lt;/p&gt;

&lt;p&gt;So what is it like developing on a legacy framework ?&lt;/p&gt;

&lt;p&gt;You can no longer rely on the community. What that means in my day to day job is that some problems I encounter which could be solved by Googling the issue if I was using a new framework can&amp;#8217;t be solved that way, and time is lost finding my own solution. Symfony has a great and large community, even for the 1.X versions. However, 1.0 was one of the shortest lived versions, so the main sources for tech answers (Stack Overflow, Google Groups) mainly have answers for 1.4 and 2.X. Which of course are partially or completely incompatible.&lt;/p&gt;

&lt;p&gt;Documentation can be hard to find now. Sensio has done a tremendous job keeping its legacy documentation online and easy to find. However, due to link rot and time passing older blog posts, tips, hints and walkthroughs are often no longer available, or harder to search for. Also, training new employees and interns is much harder as tutorials and documentation haven&amp;#8217;t been updated for newer versions of PHP/Apache/MySQL.&lt;/p&gt;

&lt;p&gt;The big one in terms of productivity: I can effectively no longer use plugins. Symfony had and still has a great plugin system, somewhat similar to Ruby On Rails gems, that enabled you to add functionnality easily. Most plugins were written for version 1.2+, no new plugins for 1.X are being written (the community for Symfony 2.X bundles however is impressive). That means I often have to develop from scratch what could have been done by just installing a plugin. I recently had to add a small CMS to our app, and had to write it from the ground up. Symfony CMSs exist of course but none are compatible with my version.&lt;/p&gt;

&lt;p&gt;Somewhat more annoying, Symfony 1.0 used Prototype (scriptaculous) as its Javascript framework, and used it somewhat extensively. This led to all our client dside code using this library instead of today&amp;#8217;s de-facto standard, jQuery. UX advances which could require just a simple jQuery plugin have to be written from scratch. (we did solve that problem - more on that in a later post).&lt;/p&gt;

&lt;p&gt;This framework is not compatible with newer versions of PHP. It was written for PHP 5.2, and is compatible with PHP 5.3 but no longer works on PHP 5.4. I haven&amp;#8217;t even tried 5.5 yet. This prevents us from using the language&amp;#8217;s new features, and we can&amp;#8217;t use new some of the new libraries.&lt;/p&gt;

&lt;p&gt;Basically I&amp;#8217;m one third less productive when programming than I could be.&lt;/p&gt;

&lt;p&gt;There are of course consequences for our users. While the code is quite maintainable, features and bug fixes aren&amp;#8217;t rolled out as fast as we&amp;#8217;d like. Users have to live with the defficiencies just a bit longer than we would like them to. Speed is an other issue. Compared to Symfony 2.X, 1.X is slow. Framework overhead is really much higher than it could be. Using 2.X would probably speed execution by a factor of 2.&lt;/p&gt;

&lt;p&gt;Apart from that though, our users don&amp;#8217;t feel the age of the framework that much. And that&amp;#8217;s why it&amp;#8217;s still more cost-efficient to keep this framework than to migrate everything. That doesn&amp;#8217;t mean I&amp;#8217;m not making life easier for myself as we go on. More on that in later posts.&lt;/p&gt;

&lt;p&gt;Could this have been avoided ?&lt;/p&gt;

&lt;p&gt;Somewhat. While it was impossible to predict at the time of the release of 1.0 that Sensio would break backward compatibility with 2.X, regular upgrades to 1.1 all the way to 1.4 would have helped. The release of 2.X however would have required the complete rewrite we were unable/unwilling to finish.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Further discussion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Reddit discussion on &lt;a href='http://www.reddit.com/r/PHP'&gt;/r/php&lt;/a&gt;: &lt;a href='http://www.reddit.com/r/PHP/comments/1knp3v/the_walking_dead_living_with_a_legacy_php/'&gt;link&lt;/a&gt;&lt;/p&gt;</description>
        <pubDate>Mon, 19 Aug 2013 00:00:00 +0200</pubDate>
        <link>/symfony/2013/08/19/the-walking-dead.html</link>
        <guid isPermaLink="true">/symfony/2013/08/19/the-walking-dead.html</guid>
      </item>
    
      <item>
        <title>Moving Forward: how we manage our product roadmap</title>
        <description>&lt;p&gt;One of my goal as our company&amp;#8217;s tech lead is to keep our product moving and not be overtaken by our competition feature-wise. My hope is that it will secure our existing clients, by giving them the key feature only we can provide. I hope it also shows them that our application is the best and fastest moving among our competitors. Of course, the other goal is to acquire new clients by having the key feature they need/want.&lt;/p&gt;

&lt;p&gt;Our company has seven people : the two founders (sales), the product manager (marketing), the account manager (client/operations), the template manager (operations/backend user), and the support person (tech support/user training), and me (tech lead). Of course, each person based on their perspective has their own idea on what we need to do to move the product forward.&lt;/p&gt;

&lt;p&gt;The previous system was an ad hoc one: decisions were made one by one depending on the situation and who was in the room. It was inefficient.&lt;/p&gt;

&lt;p&gt;Now, everytime someone has an idea or encounters a bug, they write a ticket to our Trello board, and I triage it. If it&amp;#8217;s a bug, it gets solved immediately. If it&amp;#8217;s a new feature, I do some research and evaluate the feasability and workload, then write down the steps to implement this change. Sales&amp;#8217; ideas come from questions and requests by prospects. The product manager tries and move forward on our long term product strategy and our app&amp;#8217;s user experience. The account manager will often advocate for our clients&amp;#8217; direct needs while support will talk about the clients&amp;#8217; users&amp;#8217; needs. The template manager will push for the features that make his job easier and make him more productive. I try and make myself more productive - and will often push for the &amp;#8220;cool&amp;#8221; features, those that are fun to look at or fun to implement. While there is no guarantee that is true, the overall feeling is that this approach lets us improve all the important parts of our app.&lt;/p&gt;

&lt;p&gt;Next comes the &amp;#8220;Roadmap meeting&amp;#8221;. We try to have them every three weeks. The trigger for the new meeting is the end of the previous sprint. Everybody comes. During this meeting, the product manager and I show to everybody the new features that have been developed and how they work. That way we ensure that everyone knows what our app can do as its features get added further. Any feedback can be added to a new Trello ticket.&lt;/p&gt;

&lt;p&gt;After that, we go through all the tickets on our Trello board, and one by one, decide whether to add them or not to the next sprint. Following agile practices we try to have approximately 3 weeks worth of development in our sprints. Going against agile practice, we don&amp;#8217;t just have one product owner, everybody gets a say. This hasn&amp;#8217;t yet led to any problem, as our sprints are long enough to fit something for everybody, and short enough to allow everybody to wait for next time if necessary. Final call would go to the company&amp;#8217;s CEO if it came to that, but that has never happened.&lt;/p&gt;

&lt;p&gt;Most new features then go through to the product manager who will create short mockups that let me know how it should look and act (we use Balsamiq for that). Then I get coding ! When everything in the sprint is done, we have the next Roadmap meeting.&lt;/p&gt;

&lt;p&gt;This system works pretty well for us. Everybody has enough of an input to have the app move forward enough on all fronts. Our product manager has free reign and ensures user experience and coherence, and I have a free reign in implementation.&lt;/p&gt;

&lt;p&gt;What&amp;#8217;s wrong with this system? A few things.&lt;/p&gt;

&lt;p&gt;For one thing, the roadmap grows faster that we can implement it. This sometimes leads to morale slumps, as the team does sometimes feel that we aren&amp;#8217;t moving forward, or aren&amp;#8217;t moving fast enough. That may be solved as we increase the tech team size and overall productivity. For now, though, we have to live with it.&lt;/p&gt;

&lt;p&gt;Also, we are completely unable to give a release date for any of our new features. As we are a B2B business, we have regular conversations with our clients and it can be frustrating for them to request new features and our response constantly be &amp;#8220;It&amp;#8217;s in the Roadmap, we&amp;#8217;ll get to it as soon as we can&amp;#8221;. We try to mitigate this by taking into account client feedback when defining the sprint as well as sometimes giving them release date goals (Q3 2013 for example) - on which we aren&amp;#8217;t commited. We also let our clients pay to move features up in the Roadmap. That lets them decide on their own if what they want is important enough for them to incur the cost. As you can guess, most of them prefer to wait. Some however have paid.&lt;/p&gt;

&lt;p&gt;These problems are however somewhat minor considering how much this process has let us move forward.&lt;/p&gt;</description>
        <pubDate>Mon, 12 Aug 2013 00:00:00 +0200</pubDate>
        <link>/startup/process/2013/08/12/moving-forward.html</link>
        <guid isPermaLink="true">/startup/process/2013/08/12/moving-forward.html</guid>
      </item>
    
  </channel>
</rss>